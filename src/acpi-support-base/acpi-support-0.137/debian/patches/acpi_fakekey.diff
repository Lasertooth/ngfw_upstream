diff -Nru acpi-support-0.115/acpi_fakekey.c /tmp/Umsn0ebzYy/acpi-support-0.115+thjaeger1/acpi_fakekey.c
--- acpi-support-0.115/acpi_fakekey.c	2008-09-26 00:14:34.000000000 +0100
+++ acpi-support-0.115+thjaeger1/acpi_fakekey.c	2009-01-19 09:09:31.000000000 +0000
@@ -1,68 +1,29 @@
 #include <unistd.h>
 #include <fcntl.h>
-#include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
-#include <linux/input.h>
 
-#define TestBit(bit, array) (array[(bit) / 8] & (1 << ((bit) % 8)))
-
-int find_keyboard() {
-	int i, j;
-        int fd;
-        char filename[32];
-        char key_bitmask[(KEY_MAX + 7) / 8];
-
-        for (i=0; i<32; i++) {
-                snprintf(filename,sizeof(filename), "/dev/input/event%d", i);
-
-                fd = open(filename, O_RDWR);
-		if (fd < 0) {
-			perror("open");
-			exit(EXIT_FAILURE);
-		}                
-		
-                ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(key_bitmask)), key_bitmask);
-
-		/* We assume that anything that has an alphabetic key in the
-		   QWERTYUIOP range in it is the main keyboard. */
-		for (j = KEY_Q; j <= KEY_P; j++) {
-			if (TestBit(j, key_bitmask))
-				return fd;
-		}
-
-                close (fd);
-        }
-        return 0;
-}
+#define FIFO "/dev/shm/acpi_fakekey"
 
 int main(int argc, char** argv) {
 	int fd;
-	int key;
-	struct input_event event;
+	unsigned char key;
 
-	if (argc == 2) {
-		key = atoi(argv[1]);
-	} else {
-		return 1;
+	if (argc != 2) {
+		printf("Usage: %s <key>\n", argv[0]);
+		return EXIT_FAILURE;
 	}
+	key = atoi(argv[1]);
 
-	fd = find_keyboard();
-
-	if (!fd) {
-		return 2;
+	if ((fd = open(FIFO, O_WRONLY)) == -1) {
+		perror("fifo");
+		return EXIT_FAILURE;
+	}
+	if (write(fd, &key, 1) == -1) {
+		perror("write");
+		return EXIT_FAILURE;
 	}
 
-	event.type = EV_KEY;
-	event.code = key;
-	event.value = 1;
-	write(fd, &event, sizeof event);
-
-	event.type = EV_KEY;
-	event.code = key;
-	event.value = 0;
-	write(fd, &event, sizeof event);
-	
-	return 0;
+	close(fd);
+	return EXIT_SUCCESS;
 }
-
diff -Nru /tmp/clWVJzRiJd/acpi-support-0.115/Makefile /tmp/Umsn0ebzYy/acpi-support-0.115+thjaeger1/Makefile
--- acpi-support-0.115/Makefile	2008-09-26 00:14:34.000000000 +0100
+++ acpi-support-0.115+thjaeger1/Makefile	2009-01-19 09:09:31.000000000 +0000
@@ -1,8 +1,10 @@
-all: acpi_fakekey
+all: acpi_fakekey acpi_fakekeyd
 
 acpi_fakekey: acpi_fakekey.c
-	gcc -g -Wall -o acpi_fakekey acpi_fakekey.c
-	strip acpi_fakekey
+	gcc -g -Os -Wall -o $@ $<
+
+acpi_fakekeyd: acpi_fakekeyd.c
+	gcc -g -Os -Wall -o $@ $<
 
 # Keep this manually generated so that it doesn't build-dep on
 # 'linux-headers' and stays predictable.
@@ -15,4 +19,4 @@
 	test -f aliased-keys && cat aliased-keys >> $@
 
 clean:
-	rm -f acpi_fakekey
+	$(RM) acpi_fakekey acpi_fakekeyd
--- acpi-support/acpi_fakekeyd.c	2010-06-15 12:35:38.846063228 +0200
+++ acpi-support/acpi_fakekeyd.c	2010-06-15 18:22:03.000000000 +0200
@@ -0,0 +1,103 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <linux/uinput.h>
+#include <sys/stat.h>
+
+#define FIFO "/dev/shm/acpi_fakekey"
+
+void fail(const char *str) {
+	perror(str);
+	exit(EXIT_FAILURE);
+}
+
+void daemonize() {
+	int pid;
+	if ((pid = fork()) == -1)
+		fail("fork");
+
+	if (pid)
+		exit(EXIT_SUCCESS);
+
+	if (setsid() == -1)
+		fail("setsid");
+
+	if (chdir("/") == -1)
+		fail("chdir");
+
+	if (!freopen("/dev/null", "r", stdin))
+		fail("freopen");
+	if (!freopen("/dev/null", "w", stdout))
+		fail("freopen");
+	if (!freopen("/dev/null", "w", stderr))
+		fail("freopen");
+}
+
+int main(int argc, char** argv) {
+	int fd;
+	int fifo;
+	int i;
+	struct uinput_user_dev dev;
+	fd_set sfd;
+
+	if ((fd = open("/dev/input/uinput", O_WRONLY | O_NDELAY)) == -1)
+		fail("open device");
+
+	memset(&dev, 0, sizeof(dev));
+	strncpy(dev.name, "ACPI Virtual Keyboard Device", UINPUT_MAX_NAME_SIZE);
+	dev.id.version = 4;
+	dev.id.bustype = BUS_USB;
+
+	ioctl(fd, UI_SET_EVBIT, EV_KEY);
+	for (i = 0; i < 256; i++)
+		ioctl(fd, UI_SET_KEYBIT, i);
+	if (write(fd, &dev, sizeof(dev)) == -1)
+		fail("write");
+
+	if (ioctl(fd, UI_DEV_CREATE) == -1)
+		fail("create device");
+
+	remove(FIFO);
+	if (mkfifo(FIFO, 0200) == -1)
+		fail("mkfifo");
+	
+	if ((fifo = open(FIFO, O_RDWR | O_NONBLOCK)) == -1)
+		fail("open fifo");
+
+	daemonize();
+
+	FD_ZERO(&sfd);
+	FD_SET(fifo, &sfd);
+	while (select(fifo+1, &sfd, 0, 0, 0) != -1) {
+		int n;
+		unsigned char key; 
+		struct input_event event;
+		if ((n = read(fifo, &key, 1)) == -1)
+			break;
+		if (!n)
+			continue;
+
+		event.type = EV_KEY;
+		event.code = key;
+		event.value = 1;
+		if (write(fd, &event, sizeof event) == -1)
+			break;
+		event.value = 0;
+		if (write(fd, &event, sizeof event) == -1)
+			break;
+		/* Need to write sync event */
+		memset(&event, 0, sizeof(event));
+		event.type = EV_SYN;
+		event.code = SYN_REPORT;
+		event.value = 0;
+		if (write(fd, &event, sizeof event) == -1)
+			break;
+	}
+
+	ioctl(fd, UI_DEV_DESTROY);
+	close(fd);
+	remove(FIFO);
+	return EXIT_FAILURE;
+}
